//SPDX-License-Identifier: Unlicense
/**
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@PYPB#&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@#!   :^~7JY5GB#&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@B7.         .:^~7?Y5G#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@#5!.               7@@?!?Y5GB#&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#P7^            :&@?      .:^~7?Y5#@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BJ~.         7@@?            ~#@5:^!JP&@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#5!:       ~G@B?^.    .^7G@#7      .7#@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&GJ~.     ~YB&#BGGB#&#P!.         .G@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#57^.    .^~!!~^:              .B@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#PY?77!!~~~~!!~~~~!~~^^..   ^&@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#GJ~.7@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&G&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
**/

/// Crea - Aether by Crea @ArtbyCrea 
/// Contract by @aurealarcon aurelianoa.eth

pragma solidity ^0.8.17;

import "erc721a/contracts/extensions/ERC721AQueryable.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { PaymentSplitter } from "@openzeppelin/contracts/finance/PaymentSplitter.sol";
import { ECDSA } from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import { MetadataUpdatable } from "./MetadataUpdatable.sol";

contract CreaAether is
    ERC721AQueryable, 
    Ownable, 
    ReentrancyGuard, 
    PaymentSplitter, 
    MetadataUpdatable {
    
    using ECDSA for bytes32;

    bool private isPublicMint = false;
    bool private isAllowListMint = false;
    bool private isMintPassMint = false;
    uint256 public price = 0.1 ether;
    uint256 public allowListPrice = 0.08 ether;
    uint256 public totalMaxSupply = 1111;
    uint256 private maxPerWallet = 3;
    uint256 private publicMaxPerWallet = 4;
    uint256 private mintPassMaxPerWallet = 1;
    uint256 private teamMax = 12;
    address private mintPass = 0x0000000000000000000000000000000000000000;

    /// @dev allowList mapping(address => minted)
    mapping (address => uint256) private walletsMinted;
    /// @dev public mapping(address => minted)
    mapping(address => uint256) private publicWalletsMinted;
    /// @dev usedMintPasses mapping(tokenId => bool)
    mapping(uint256 => bool) private usedMintPasses;
    /// @dev mintPassMinted mapping(address => minted)
    mapping (uint256 => uint256) private mintPassMinted;

    constructor(
        string memory name,
        string memory symbol, 
        address[] memory _payees, 
        uint256[] memory _shares
        ) 
        ERC721A(name, symbol) 
        PaymentSplitter(_payees, _shares) 
    {}

    ///ADMINISTRATIVE TOOLS

    /// @dev set Mint State
    /// @param _mintPass bool
    /// @param allowList bool
    /// @param publicList bool
    function setMintState(bool _mintPass, bool allowList, bool publicList) external onlyOwner {
        isAllowListMint = allowList;
        isPublicMint = publicList;
        isMintPassMint = _mintPass;
    }

    /// @notice update max per wallet for each state
    /// @dev 0 => public, 1 => allowList, 2 => mintPass
    /// @param mintState bool
    function updateMaxPerwallet(uint256 max, uint256 mintState) external onlyOwner {
        if(mintState == 0) {
            publicMaxPerWallet = max;
        } else if(mintState == 1) {
             maxPerWallet = max;
        } else if(mintState == 2) {
            mintPassMaxPerWallet = max;
        }
    }

    /// @notice update mintPass Address
    /// @param _mintPass address
    
    function updateMintPass(address _mintPass) external onlyOwner {
        mintPass = _mintPass;
    }


    function _startTokenId() internal view virtual override returns (uint256) {
      return 1;
    }

    /// modifiers

    /// @notice checks if the wallet is allow listed recovering from signature
    /// @param allowListed address
    /// @param _signature bytes memory
    modifier onlyAllowlisted(address allowListed, bytes memory _signature) {
        require(isAllowListMint, "AllowList mint is not active");
        require(isAllowListMinted( allowListed, _signature), "Address not in Allowlist");

        _;
    }

    /// Mint multiple ERC721 tokens
    /// @notice this will receive an array to set the seedMetadata per tokenId
    /// @param owner address
    /// @param variants string[]
    function mint(address owner, string[] memory variants) internal {
        uint256 i = 0;
        uint256 tokenId = totalSupply() + 1;
        do {
            require(isValidVariant(variants[i]),"No valid variant provided");
            _mint(owner, 1);
            _setSelectedVariant(tokenId + i, variants[i]);
            unchecked { ++i; }
        } while (i < variants.length);
    }

    /// Mint by team Members
    /// @notice same rules for the mint function
    /// @param variants string[]
    function teamMint(string[] memory variants) external onlyOwner {
        require(totalSupply() + variants.length <= teamMax, "team mint supply exceeded");
    
        mint(msg.sender, variants);
    }

    /// Mint from the Allow list
    /// @param variants string[]
    /// @param signature bytes
    function allowListMint(string[] memory variants, bytes memory signature) external payable 
    onlyAllowlisted(msg.sender, signature) {
        uint256 count = variants.length;

        require(count <= maxPerWallet, "Maximum per transaction");
        require(totalSupply() + count <= totalMaxSupply, "all tokens already minted"); 
        require(count <= maxPerWallet - walletsMinted[msg.sender], "Maximum per wallet exceeded");
        require(msg.value == count * allowListPrice, "wrong eth sent");

        walletsMinted[msg.sender] += count; 
        mint(msg.sender, variants);
    }

    /// public mint
    /// @param variants string[] 
    function publicMint(string[] memory variants) external payable 
    nonReentrant {
        require(isPublicMint, "Public mint is not active");

        uint256 count = variants.length;

        require(count <= publicMaxPerWallet, "Maximum per transaction");
        require(totalSupply() + count <= totalMaxSupply, "all tokens already minted");
        require(count <= publicMaxPerWallet - publicWalletsMinted[msg.sender], "Maximum per wallet exceeded");
        require(msg.value == count * price, "wrong eth sent");

        publicWalletsMinted[msg.sender] += count;
        mint(msg.sender, variants);
    }

    /// CreaChronos Mint Pass Claim
    /// @notice this will check if the owners owns a Chronos Mint Pass ERC 721 Token
    /// @param tokenId uint256
    /// @param variant string

    function claimWithMintPass(uint256 tokenId, string memory variant) external {
        require(isMintPassMint, "Mint Pass mint is not active");
        require(totalSupply() + 1 <= totalMaxSupply, "all tokens already minted");
        require(mintPass != address(0), "Mint Pass not set");
        require(IERC721A(mintPass).ownerOf(tokenId) == msg.sender, "You dont own this token");
        require(!usedMintPasses[tokenId], "This token has already been used");

        /// @dev we update the usage of the token
        usedMintPasses[tokenId] = true;

        string[] memory variants = new string[](1);
        variants[0] = variant;

        mint(msg.sender, variants);
    }

    /// Mint multiple with Mint Pass
    /// @notice this will check if the owners owns a Chronos Mint Pass ERC 721 Token
    /// @param tokenId uint256
    /// @param variants string[]
    function mintWithMintPass(uint256 tokenId, string[] memory variants) external payable
    nonReentrant {
        require(isMintPassMint, "Mint Pass mint is not active");

        uint256 count = variants.length;

        require(totalSupply() + count <= totalMaxSupply, "all tokens already minted");
        require(mintPass != address(0), "Mint Pass not set");
        require(IERC721A(mintPass).ownerOf(tokenId) == msg.sender, "You dont own this token");
        require(count <= mintPassMaxPerWallet - mintPassMinted[tokenId], "Maximum per wallet exceeded");
        require(msg.value == count * allowListPrice, "wrong eth sent");

        mintPassMinted[tokenId] += count;
        mint(msg.sender, variants);
    }


    /// Claim with mint pass multiple tokens
    /// @notice this will check if the owners owns a Chronos Mint Pass ERC 721 Token
    /// @param tokenIds uint256[]
    /// @param variants string[]
    function claimWithMintPassMultiple(uint256[] memory tokenIds, string[] memory variants) external {
        require(isMintPassMint, "Mint Pass mint is not active");
        require(mintPass != address(0), "Mint Pass not set");
        require(tokenIds.length == variants.length, "Array length mismatch");

        uint256 count = tokenIds.length;

        require(totalSupply() + count <= totalMaxSupply, "all tokens already minted");

        uint256 i = 0;
        do {
            uint256 tokenId = tokenIds[i];

            require(IERC721A(mintPass).ownerOf(tokenId) == msg.sender, "You dont own this token");
            require(!usedMintPasses[tokenId], "This token has already been used");

            /// @dev we update the usage of the token
            usedMintPasses[tokenId] = true;
            unchecked { ++i; }
        } while(i < count);

        mint(msg.sender, variants);
    }

    /// Update variant
    /// @notice the holder can update the gender metadata of the given token
    /// @param tokenId uint256
    /// @param variant string
    function updateVariant(uint256 tokenId, string memory variant) external payable {
        require(isMetadataRevealed(), "Metadata not revealed yet");
        require(ownerOf(tokenId) == msg.sender, "you dont own this token");
        require(msg.value == getVariantPrice(variant), "wrong ETH Sent");
        _setSelectedVariant(tokenId,  variant);
    }

    /// get tokenMetadata
    /// @notice it will use the MetadataUpdatable
    /// @param tokenId uint256
    /// @return string
    function tokenURI(uint256 tokenId) public view override(ERC721A, IERC721A) returns (string memory) {
        require(_exists(tokenId), "Token does not exist");

        return getTokenURI(tokenId);
    }

    /// get max mints left
    /// @notice get mints left by user depending on the mint state
    /// @param owner address
    /// @return uint256 
    function maxMintLeft(address owner) external view returns (uint256) {
        return isAllowListMint ? maxPerWallet - walletsMinted[owner] : 
        publicMaxPerWallet - publicWalletsMinted[owner];
    }

    /// @notice checks if the wallet is allow listed recovering from signature
    /// @param allowListed address
    /// @param _signature bytes memory
    /// @return bool
    function isAllowListMinted(address allowListed, bytes memory _signature) public view returns(bool) {

        bytes32 messagehash = keccak256(
            abi.encodePacked(address(this), allowListed)
        );
        address signer = messagehash.toEthSignedMessageHash().recover(
            _signature
        );

        return signer == owner();
    }

    /// allowlist mint getter
    /// @return bool
    function isAllowListMintActive() external view returns (bool) {
        return isAllowListMint;
    }

    /// public mint getter
    /// @return bool
    function isPublicMintActive() external view returns (bool) {
        return isPublicMint;
    }

    /// mintPass mint getter
    /// @return bool
    function isMintPassMintActive() external view returns (bool) {
        return isMintPassMint;
    }

    /// @notice get the status of the mint pass
    /// @param tokenId uint256
    /// @return bool
    function isMintPassUsed(uint256 tokenId) external view returns (bool) {
        return usedMintPasses[tokenId];
    }

}